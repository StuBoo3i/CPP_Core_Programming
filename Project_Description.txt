c++核心编程

1.内存分区
c++程序在执行时，在内存上划分为4个区域：
    代码区：存放函数体的二进制代码，由操作系统进行管理。
    全局区：存放全局变量、静态变量以及变量。
    栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
    堆区：由程序员分配释放，不释放时程序结束后由操作系统回收。
划分使不同的区域存放不同的数据，赋予不同的生命周期，提升编程的灵活性。

1.1程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域。
    代码区：（共享 只读）
        存放CPU执行的机器指令。
        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。
        代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令。
    全局区：（os控制）
        全局变量和静态变量存放于此。
        还包含常量区，字符串常量和其他常量（const等）。
        该区域的数据在程序结束后由操作系统释放。

1.2程序运行时
    栈区：
        由编译器自动分配释放，存放函数的参数值，局部变量等。
        不要返回局部变量的地址，栈区开辟的数据在函数或程序结束后由编译器自动释放。
    堆区：
        由程序员分配释放，或程序结束后由操作系统回收。
        在C++中主要利用new在堆区开辟内存。

1.3new
    c++中利用new操作符在对去开辟数据。
    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete。
    语法：new 数据类型
    利用new创建的数据，会返回数据对应的类型的指针。。

2 引用
2.1基本使用
    作用：给变量起别名
    语法：数据类型 &别名 = 原名; (两者指向的是同一块内存地址)
2.2注意事项
    必须初始化。
    引用初始化之后，不可以改变（即 &b=c 不能执行）。
2.3引用做函数参数
    作用：函数传参时，可以利用引用的技术让形参修饰实参（1、值传递 2、地址传递（指针））。
    优点：可以简化指针修改实参。
2.4引用做函数返回值
    作用：引用可以作为函数的返回值存在的。
    注意：不能返回局部变量引用。
    用法：函数调用作为左值。
2.5引用的本质
    引用在C++内部实现是一个指针常量：将 int &ref = a; 转换为 int * const ref = &a; 指针的指向不可以改变，但值可以变。
2.6常量引用
    作用：常量引用主要用来修饰形参，防止误操作。
    在函数形参列表中，可以加const修饰形参，防止形参改变实参。

3函数
3.1函数的默认参数
    在c++中，函数的形参列表中的形参是可以有默认值的。
    语法：返回值类型 函数名 (参数 = 默认值) {}
        1.如果某个位置参数有默认值，那么从这个地址往后，从左到右，必须到要有默认值。
        2.如果函数的声明有默认值，函数实现的时候就不能有默认参数。
3.2函数占位参数
    C++函数的形参列表里可以有占位参数，用作占位，调用函数的时候必须填补该位置。
    语法：返回值类型 函数名(数据类型){}
3.3函数重载
    3.3.1概述
        作用：函数名相同以提高复用性。
        函数重载满足条件：
            1.同一个作用域下。
            2.函数名相同。
            3.函数参数类型不同或者参数个数不同或者参数顺序不同。
        注意：函数的返回值不可以作为函数重载的条件。
    3.3.2注意事项
        引用作为重载条件。
        函数重载与默认参数。

4类和对象
C++面向对象的三大特性为:封装，继承，多态。
4.1封装
    4.1.1封装的意义
        1.将属性和行为作为一个整体，表现生活中的事务。
        2.将属性和行为加以权限限制。
        eg:
        在设计类的时候，属性和行为写在一起，表现事物。
        语法：
        class 类名{   访问权限：属性/行为 };
        eg:
        设计类时，可以把属性和权限放在不同的权限下，加以控制。
            1.public        成员 类内可以访问   类外可以访问      子类可以访问
            2.protected     成员 类内可以访问   类外不可以访问     子类可以访问
            3.private       成员 类内可以访问   类外不可以访问     子类不可以访问
    4.1.2struct与class的区别
        在C++中两者的唯一区别就是访问权限不同。
        1.struct默认权限为公共。
        2.class 默认权限为私有。
    4.1.3将成员属性设置为私有
        优点1：将成员属性设置为私有，可以自己控制读写权限。
        优点2：对于写权限，我们可以检测数据的有效性。
4.2对象的初始化和清理
    4.2.1 构造函数和析构函数
    对象的初始化和清理也是两个非常重要的安全问题。
        一个对象或者变量没有初始状态，对其的使用后果是未知的。
        同样的，使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。
    C++利用构造函数和析构函数解决了上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理任务。
    如果我们不提供给构造函数和析构函数，编译器会提供空实现的构造函数和析构函数。
        构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
        析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理的任务。
    构造函数语法：类名(){}
        1.没有返回值也不写void。
        2.函数名与类名相同。
        3.构造函数可以有参数，因此可以发生重载。
        4.程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次。
    析构函数语法：~类名(){}
        1.没有返回值也不写void。
        2.函数名与类名相同,在名称前面加上符号~。
        3.构造函数不可以有参数，因此不可以发生重载。
        4.程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次。
    4.2.2构造函数的分类和调用
        按参数分为：有参构造和无参构造。
        按类型分为：普通构造和拷贝构造。
        把调用方式分为：括号法、显示法、隐式转换法。
    4.2.3拷贝构造函数的调用时机
    C++中拷贝构造函数调用时机有以下三种：
        1.使用一个已经创建完毕的对象来初始化一个新对象。
        2.值传递的方式给函数参数传值。
        3.以值的方式返回局部变量。
    4.2.4构造函数调用规则
    默认情况下，C++编译器至少给一个类添加3个函数。
        1.默认无参构造
        2.默认析构函数
        3.默认拷贝函数
    调用规则如下：
        1.用户定义有参构造函数，C++不在提供无参构造函数，但是提供默认拷贝构造函数。
        2.用户定义拷贝构造函数，C++不在提供其他构造函数。
    4.2.5深拷贝与浅拷贝（面试经典问题）
        浅拷贝：简单的复制拷贝操作，浅拷贝带来的问题是堆区的内存会重复释放，要利用深拷贝来解决。
        深拷贝：在堆区重新申请空间，进行拷贝操作。
    4.2.6初始化列表
        C++提供了初始化列表，用来初始化属性
        语法：构造函数():属性值1(值1),属性值2(值2),属性值3(值3),....{}
    4.2.7对象成员
        C++中的类中的成员可以是另一个类的对象，称为成员对象。
        类a与其对象成员类b的构造析构顺序是：对象成员的类的对象先创建，销毁顺序则相反。
    4.2.8静态成员
        成员变量之前加上static，称为静态成员。
        1.静态成员变量:
            a.所有对象共享一份数据。
            b.在编译阶段分配内存。
            c.类内声明，类外初始化。
        2.静态成员函数
            a.所有对象共享一个函数。
            b.静态成员函数只能访问静态成员变量。
        静态成员变量可以通过对象去访问，也可以通过类名去访问,静态成员变量也有对应的访问权限。
        静态成员函数可以通过对象去访问，也可以通过类名去访问,静态成员函数也有对应的访问权限。
4.3C++对象模型和this指针
    4.3.1成员变量和成员函数分开存储
        在C++中，类的成员变量和成员函数分开存储。
        只有非静态成员变量才属于类的对象上。
        C++编译器会给每个空对象也分配一个字节的内存空间，这是为了区分空对象所占的内存的位置，使每一个空对象都有一个独一无二的内存地址。
        静态成员变量不属于某个对象，不占对象的内存空间，成员函数也是独一份，不占对象的内存空间。
    4.3.2this指针
        通过以上我们知道C++中，类的成员变量和成员函数分开存储。
        每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码如何区分是哪一个对象调用自己吗？
        C++通过提供特殊的对象指针，this指针，解决了上述问题。this指针只想被调用的成员函数所属的对象。
        this指针是隐含每一个非静态成员函数内的一种指针，不需要被定义，可以直接使用。
        this指针的用途：
            1.当型参与成员变量重名时进行区分。
            2.在类的非静态成员函数中返回对象本身，可使用return *this;
    4.3.3空指针访问成员函数
        C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针，如果用到this指针就要加以判断来保证代码的健壮性。
    4.3.4const修饰成员函数
        常函数：
            1.成员函数后加const后我们将其称为常函数。
            2.长函数内不可以修改成员属性。
            3.成员属性声明时加关键字mutable后，在常函数中也可以进行修改。
        长对象：
            1.声明对象前加const称该对象为常对象。
            2.常对象只能调用常函数。
        在成员函数后加const本质上修饰的是this指针，使其值也不可以修改。
4.4友元
    生活中你家有客厅，有卧室，前者所有来的客人都可以进入，但是后者是私有的只有你能进去。
    但是你可以让你的朋友进去。
    在程序中，有些私有的属性也想让类外的一些特殊函数或者类进行访问，这就需要友元。
    友元使一个函数或者类访问另一个类中的私有成员，关键字：friend。
    4.4.1全局函数做友元
    4.4.2友元类
    4.4.3成员函数做友元   PS.在这种情况下为了符合两个类的调用可以符合语法地被编译，可以将相关函数代码在类外进行定义。
4.5运算符重载
    对已有的运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型。
    4.5.1加号
    运算符重载之后也可以通过函数重载扩展。
    4.5.2左移运算符重载（<<）
    作用：可以输出自定义数据类型，一般不会使用成员函数重载左移运算符。
    4.5.3递增运算符重载（++）
    4.5.4赋值运算符重载
    C++编译器至少给一个类添加了4个函数
        1.默认无参构造
        2.默认析构函数
        3.默认拷贝函数
        4.赋值运算符operator+，对属性进行拷贝。
        如果类中有属性指向堆区，做赋值运算也会出现深浅拷贝问题。
    通过赋值运算符重载解决浅拷贝问题。
    4.5.5关系运算符重载（==）
    4.5.6函数调用运算符重载
        1.函数调用运算符（）也可以重载。
        2.由于重载后使用的方式非常像函数的调用，因此成为仿函数。
        3.仿函数没有固定写法，非常灵活。
4.6继承
    4.6.1基本语法
        class 子类：继承方式 父类{

        }
        子类又称派生类，父类又称基类。
    4.6.2继承方式
        1.公共继承
        2.保护继承
        3.私有继承
        父类的私有成员无论子类何种继承方式都无法访问。
        公有继承使继承来自父类的成员的属性不变；保护继承使子类继承的公共成员变为保护成员；私有继承使子类继承到的所有成员都变为私有成员。
        保护权限类外访问不到。
    4.6.3继承中的对象模型
        父类中私有成员在继承过程中只是被隐藏了，但是还是会继承下去，即父类中所有非静态的成员属性都会被子类继承。
        利用开发人员命令提示工具查看对象模型：
            1.跳转CPP文件所在文件夹 cd/...
            2.查看命令： cl /d1 reportSingleClassLayout类名 文件名
    4.6.4继承中的构造和析构顺序
        生成子类对象时，要先构造父类对象，在构造子类对象，析构时先析构子类对象再析构父类对象。
    4.6.5继承·同名成员处理方式
        1.访问子类同名成员，直接访问即可。
        2.访问父类同名成员，需要加作用域。
        e.g. ’Son s; s.Base::a;‘
        如果子类中出现了与父类同名的成员函数，子类的同名成员会导致父类中所有的同名成员都被隐藏。
    4.6.6继承同名静态成员处理方式
        1.访问子类同名成员，直接访问即可。
        2.访问父类同名成员，需要加作用域。
    4.6.7多继承语法
    c++允许一个类继承多个类
        语法：class 子类 : 继承方式 父类1 , 继承方式 父类2 , 继承方式 父类3 ....
        多继承可能会引发父类中有同名成员出现，需要加作用域进行区分。
        C++实际开发不建议用多继承。
    4.6.8菱形继承
    概念：
        1.两个派生类继承自同一个基类。
        2.某个类同时继承了这两个派生类。
        3.称为菱形继承或钻石继承。
    来自最初基类的数据继承了两份，但只需要一份即可。
    利用虚继承可以解决菱形继承的问题，即在继承之前加上‘virtual’关键字变成虚继承，基类叫虚基类。
    虚继承会使用一个虚基类指针vbptr指向了虚基类表vbtable，该表中记录了不同成员的偏移量，使得重复的成员只有一份。
4.7多态
    4.7.1基本概念
        1.静态多态：函数重载和运算符重载属于静态多态，复用函数名。
        2.动态多态：派生类和虚函数实现运行时多态
    两者区别：
        1.静态多态的函数地址早绑定-编译阶段确定函数地址
        2.动态多态的函数地址晚绑定-运行阶段确定函数地址
        动态多态满足条件
         * 1.有继承关系
         * 2.子类重写父类虚函数
         * 重写：函数的返回值类型，函数名，参数列表要完全相同。
         * 子类重写的虚函数的virtual可写可不写
         原理：
         * 父类当每有一个虚函数时，类的对象会生成一个虚函数（表）指针vfptr（4B），该指针指向虚函数表vftable，表内记录了虚函数。
         * 子类没有重写虚函数时会继承虚函数指针，重写虚函数后子类的虚函数表会被覆盖，指针指向换为子类的虚函数地址，当父类的指针或者引用指向子类对象时就会发生多态。
        多态的优势：
            1.代码组织结构清晰
            2.可读性强
            3.有利于前期和后期的拓展和维护
    4.7.3纯虚函数和抽象类
        在多态中，通常父类中虚函数的实现是毫无意义的，主要是调用子类重写的内容，因此可以将虚函数改为纯虚函数。
        语法：virtual 返回值类型 函数名 (参数列表) = 0;
        当类中有了纯虚函数，这个类可以称为抽象类。
        抽象类的特点：
            1.无法实例化
            2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类。
    4.7.5虚析构和纯虚析构
        多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构函数代码
        解决方式：将父类中的析构函数改为虚析构或纯虚析构
        虚析构和纯虚析构共性：
            1.可以解决父类指针释放子类对象
            2.都需要有具体的函数实现
        区别：
            1.如果是纯虚析构，该类属于抽象类而无法被实例化，但是纯虚析构有时即需要声明也需要实现。
5文件操作
    程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过文件可以将数据持久化，C++中对文件操作需要包含头文件<fstream>
    文件类型分为两种:
        1.文本文件- 文件以文本的ASCII码形式存储在计算机中
        2.二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们
    操作文件的三大类:
        1.ofstream:写操作
        2.ifstream: 读操作
        3.fstream :读写操作
5.1文本文件
    5.1.1写文件
    写文件步骤如下:
        1.包含头文件：#include <fstream>
	    2.创建流对象：ofstream ofs;
        3.打开文件：ofs.open("文件路径",打开方式);
        4.写数据：ofs <<"写入的数据";
        5.关闭文件：ofs.close();
    文件打开方式:
        打开方式	    解释
        ios::in	    为读文件而打开文件
        ios::out	为写文件而打开文件
        ios::ate	初始位置:文件尾
        ios::app	追加方式写文件
        ios::trunc	如果文件存在先删除，再创建
        los::binary	二进制方式
    注意:文件打开方式可以配合使用，利用|操作符
    例如:用二进制方式写文件ios::binary | ios:: out
    5.1.2读文件
    读文件步骤如下:
        1.包含头文件：#include <fstream>
        2.创建流对象：ifstream ifs;
        3.打开文件并判断文件是否打开成功：ifs.open("文件路径",打开方式);
        4.读数据：四种方式读取
        5.关闭文件：ifs.close();
5.2二进制文件
    5.2.1写
        调用write函数：ostream& write(const char* buffer, int len);
        字符指针buffer指向内存中的一段存储空间，len为字节数。
    5.2.2读
        调用read函数：istream& read(const char* buffer, int len);
        字符指针buffer指向内存中的一段存储空间，len为字节数。