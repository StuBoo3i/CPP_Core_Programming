c++核心编程

1.内存分区
c++程序在执行时，在内存上划分为4个区域：
    代码区：存放函数体的二进制代码，由操作系统进行管理。
    全局区：存放全局变量、静态变量以及变量。
    栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
    堆区：由程序员分配释放，不释放时程序结束后由操作系统回收。
划分使不同的区域存放不同的数据，赋予不同的生命周期，提升编程的灵活性。

1.1程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域。
    代码区：（共享 只读）
        存放CPU执行的机器指令。
        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。
        代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令。
    全局区：（os控制）
        全局变量和静态变量存放于此。
        还包含常量区，字符串常量和其他常量（const等）。
        该区域的数据在程序结束后由操作系统释放。

1.2程序运行时
    栈区：
        由编译器自动分配释放，存放函数的参数值，局部变量等。
        不要返回局部变量的地址，栈区开辟的数据在函数或程序结束后由编译器自动释放。
    堆区：
        由程序员分配释放，或程序结束后由操作系统回收。
        在C++中主要利用new在堆区开辟内存。

1.3new
    c++中利用new操作符在对去开辟数据。
    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete。
    语法：new 数据类型
    利用new创建的数据，会返回数据对应的类型的指针。。

2 引用
2.1基本使用
    作用：给变量起别名
    语法：数据类型 &别名 = 原名; (两者指向的是同一块内存地址)
2.2注意事项
    必须初始化。
    引用初始化之后，不可以改变（即 &b=c 不能执行）。
2.3引用做函数参数
    作用：函数传参时，可以利用引用的技术让形参修饰实参（1、值传递 2、地址传递（指针））。
    优点：可以简化指针修改实参。
2.4引用做函数返回值
    作用：引用可以作为函数的返回值存在的。
    注意：不能返回局部变量引用。
    用法：函数调用作为左值。
2.5引用的本质
    引用在C++内部实现是一个指针常量：将 int &ref = a; 转换为 int * const ref = &a; 指针的指向不可以改变，但值可以变。
2.6常量引用
    作用：常量引用主要用来修饰形参，防止误操作。
    在函数形参列表中，可以加const修饰形参，防止形参改变实参。

3函数
3.1函数的默认参数
    在c++中，函数的形参列表中的形参是可以有默认值的。
    语法：返回值类型 函数名 (参数 = 默认值) {}
        1.如果某个位置参数有默认值，那么从这个地址往后，从左到右，必须到要有默认值。
        2.如果函数的声明有默认值，函数实现的时候就不能有默认参数。
3.2函数占位参数
    C++函数的形参列表里可以有占位参数，用作占位，调用函数的时候必须填补该位置。
    语法：返回值类型 函数名(数据类型){}
3.3函数重载
    3.3.1概述
        作用：函数名相同以提高复用性。
        函数重载满足条件：
            1.同一个作用域下。
            2.函数名相同。
            3.函数参数类型不同或者参数个数不同或者参数顺序不同。
        注意：函数的返回值不可以作为函数重载的条件。
    3.3.2注意事项
        引用作为重载条件。
        函数重载与默认参数。

4类和对象
C++面向对象的三大特性为:封装，继承，多态。
4.1封装
    4.1.1封装的意义
        1.将属性和行为作为一个整体，表现生活中的事务。
        2.将属性和行为加以权限限制。
        eg:
        在设计类的时候，属性和行为写在一起，表现事物。
        语法：
        class 类名{   访问权限：属性/行为 };
        eg:
        设计类时，可以把属性和权限放在不同的权限下，加以控制。
            1.public        成员 类内可以访问   类外可以访问      子类可以访问
            2.protected     成员 类内可以访问   类外不可以访问     子类可以访问
            3.private       成员 类内可以访问   类外不可以访问     子类不可以访问
    4.1.2struct与class的区别
        在C++中两者的唯一区别就是访问权限不同。
        1.struct默认权限为公共。
        2.class 默认权限为私有。
    4.1.3将成员属性设置为私有
        优点1：将成员属性设置为私有，可以自己控制读写权限。
        优点2：对于写权限，我们可以检测数据的有效性。
4.2对象的初始化和清理
    4.2.1 构造函数和析构函数
    对象的初始化和清理也是两个非常重要的安全问题。
        一个对象或者变量没有初始状态，对其的使用后果是未知的。
        同样的，使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。
    C++利用构造函数和析构函数解决了上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理任务。
    如果我们不提供给构造函数和析构函数，编译器会提供空实现的构造函数和析构函数。
        构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
        析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理的任务。
    构造函数语法：类名(){}
        1.没有返回值也不写void。
        2.函数名与类名相同。
        3.构造函数可以有参数，因此可以发生重载。
        4.程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次。
    析构函数语法：~类名(){}
        1.没有返回值也不写void。
        2.函数名与类名相同,在名称前面加上符号~。
        3.构造函数不可以有参数，因此不可以发生重载。
        4.程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次。
    4.2.2构造函数的分类和调用
        按参数分为：有参构造和无参构造。
        按类型分为：普通构造和拷贝构造。
        把调用方式分为：括号法、显示法、隐式转换法。
    4.2.3拷贝构造函数的调用时机
    C++中拷贝构造函数调用时机有以下三种：
        1.使用一个已经创建完毕的对象来初始化一个新对象。
        2.值传递的方式给函数参数传值。
        3.以值的方式返回局部变量。
    4.2.4构造函数调用规则
    默认情况下，C++编译器至少给一个类添加3个函数。
        1.默认无参构造
        2.默认析构函数
        3.默认拷贝函数
    调用规则如下：
        1.用户定义有参构造函数，C++不在提供无参构造函数，但是提供默认拷贝构造函数。
        2.用户定义拷贝构造函数，C++不在提供其他构造函数。
    4.2.5深拷贝与浅拷贝（面试经典问题）
        浅拷贝：简单的复制拷贝操作，浅拷贝带来的问题是堆区的内存会重复释放，要利用深拷贝来解决。
        深拷贝：在堆区重新申请空间，进行拷贝操作。
    4.2.6初始化列表
        C++提供了初始化列表，用来初始化属性
        语法：构造函数():属性值1(值1),属性值2(值2),属性值3(值3),....{}
    4.2.7对象成员
        C++中的类中的成员可以是另一个类的对象，称为成员对象。
        类a与其对象成员类b的构造析构顺序是：对象成员的类的对象先创建，销毁顺序则相反。
    4.2.8静态成员
        成员变量之前加上static，称为静态成员。
        1.静态成员变量:
            a.所有对象共享一份数据。
            b.在编译阶段分配内存。
            c.类内声明，类外初始化。
        2.静态成员函数
            a.所有对象共享一个函数。
            b.静态成员函数只能访问静态成员变量。
        静态成员变量可以通过对象去访问，也可以通过类名去访问,静态成员变量也有对应的访问权限。
        静态成员函数可以通过对象去访问，也可以通过类名去访问,静态成员函数也有对应的访问权限。
4.3C++对象模型和this指针
    4.3.1成员变量和成员函数分开存储
        在C++中，类的成员变量和成员函数分开存储。
        只有非静态成员变量才属于类的对象上。
        C++编译器会给每个空对象也分配一个字节的内存空间，这是为了区分空对象所占的内存的位置，使每一个空对象都有一个独一无二的内存地址。
        静态成员变量不属于某个对象，不占对象的内存空间，成员函数也是独一份，不占对象的内存空间。
    4.3.2this指针
        通过以上我们知道C++中，类的成员变量和成员函数分开存储。
        每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码如何区分是哪一个对象调用自己吗？
        C++通过提供特殊的对象指针，this指针，解决了上述问题。this指针只想被调用的成员函数所属的对象。
        this指针是隐含每一个非静态成员函数内的一种指针，不需要被定义，可以直接使用。
        this指针的用途：
            1.当型参与成员变量重名时进行区分。
            2.在类的非静态成员函数中返回对象本身，可使用return *this;
    4.3.3空指针访问成员函数
        C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针，如果用到this指针就要加以判断来保证代码的健壮性。
    4.3.4const修饰成员函数
        常函数：
            1.成员函数后加const后我们将其称为常函数。
            2.长函数内不可以修改成员属性。
            3.成员属性声明时加关键字mutable后，在常函数中也可以进行修改。
        长对象：
            1.声明对象前加const称该对象为常对象。
            2.常对象只能调用常函数。
        在成员函数后加const本质上修饰的是this指针，使其值也不可以修改。
4.4友元
    生活中你家有客厅，有卧室，前者所有来的客人都可以进入，但是后者是私有的只有你能进去。
    但是你可以让你的朋友进去。
    在程序中，有些私有的属性也想让类外的一些特殊函数或者类进行访问，这就需要友元。
    友元使一个函数或者类访问另一个类中的私有成员，关键字：friend。
    4.4.1全局函数做友元
    4.4.2友元类
    4.4.3成员函数做友元   PS.在这种情况下为了符合两个类的调用可以符合语法地被编译，可以将相关函数代码在类外进行定义。
4.5运算符重载
    对已有的运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型。
    4.5.1加号
    运算符重载之后也可以通过函数重载扩展。
    4.5.2左移运算符重载（<<）
    作用：可以输出自定义数据类型，一般不会使用成员函数重载左移运算符。
    4.5.3递增运算符重载（++）
    4.5.4赋值运算符重载
    C++编译器至少给一个类添加了4个函数
        1.默认无参构造
        2.默认析构函数
        3.默认拷贝函数
        4.赋值运算符operator+，对属性进行拷贝。
        如果类中有属性指向堆区，做赋值运算也会出现深浅拷贝问题。
    通过赋值运算符重载解决浅拷贝问题。
    4.5.5关系运算符重载

















